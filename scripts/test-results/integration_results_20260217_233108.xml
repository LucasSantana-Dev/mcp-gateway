<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="9" failures="0" skipped="0" tests="9" time="10.334" timestamp="2026-02-17T23:31:20.305763" hostname="MacBook-Pro-de-Lucas-10.local"><testcase classname="tests.test_integration_sleep_wake.TestIntegrationSleepWake" name="test_complete_sleep_wake_cycle" time="0.087"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107b66460&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107b66310&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107a7ef70&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107b66460&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107a7ef70&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationSleepWake" name="test_memory_optimization_during_sleep" time="0.012"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107d3f9a0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107d3fbe0&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107d3f130&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107d3f9a0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107d3f130&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationSleepWake" name="test_resource_monitoring_accuracy" time="0.010"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107dae7c0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107dae6a0&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107daef70&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107dae7c0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107daef70&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationSleepWake" name="test_state_transition_tracking" time="0.067"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107df17c0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107df1670&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107df1f40&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107df17c0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107df1f40&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationSleepWake" name="test_alerting_system_integration" time="0.008"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107e46280&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107e46160&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107e46c70&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107e46280&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107e46c70&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationSleepWake" name="test_error_handling_and_recovery" time="0.082"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107d637c0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107d63670&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107d63f40&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107d637c0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107d63f40&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationSleepWake" name="test_concurrent_operations" time="0.016"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107e57070&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107e57f40&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107e57820&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107e57070&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107e57820&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationPerformanceTargets" name="test_wake_time_performance_target" time="0.015"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107e5fbb0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107e5fbe0&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107e5f280&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107e5fbb0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107e5f280&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase><testcase classname="tests.test_integration_sleep_wake.TestIntegrationPerformanceTargets" name="test_memory_efficiency_target" time="0.008"><error message="failed on setup with &quot;docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker&quot;">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107d635e0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
&gt;           conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:466: in get_connection_with_tls_context
    conn = self.poolmanager.connection_from_host(
../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:319: in connection_from_host
    return self.connection_from_context(request_context)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib3.poolmanager.PoolManager object at 0x107d63490&gt;, request_context = {'block': False, 'cert_reqs': 'CERT_REQUIRED', 'host': 'localhost', 'maxsize': 10, ...}

    def connection_from_context(
        self, request_context: dict[str, typing.Any]
    ) -&gt; HTTPConnectionPool:
        """
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.
    
        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        """
        if "strict" in request_context:
            warnings.warn(
                "The 'strict' parameter is no longer needed on Python 3+. "
                "This will raise an error in urllib3 v2.1.0.",
                DeprecationWarning,
            )
            request_context.pop("strict")
    
        scheme = request_context["scheme"].lower()
        pool_key_constructor = self.key_fn_by_scheme.get(scheme)
        if not pool_key_constructor:
&gt;           raise URLSchemeUnknown(scheme)
E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/urllib3/poolmanager.py:341: URLSchemeUnknown

During handling of the above exception, another exception occurred:

self = &lt;docker.api.client.APIClient object at 0x107d63e20&gt;

    def _retrieve_server_version(self):
        try:
&gt;           return self.version(api_version=False)["ApiVersion"]

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/api/daemon.py:181: in version
    return self._result(self._get(url), json=True)
../../../Library/Python/3.9/lib/python/site-packages/docker/utils/decorators.py:46: in inner
    return f(self, *args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:237: in _get
    return self.get(url, **self._set_request_timeout(kwargs))
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:602: in get
    return self.request("GET", url, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
../../../Library/Python/3.9/lib/python/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x107d635e0&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
&gt;           raise InvalidURL(e, request=request)
E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/requests/adapters.py:614: InvalidURL

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def docker_client():
        """Create a real Docker client for integration testing."""
&gt;       return docker.from_env()

tests/test_integration_sleep_wake.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:96: in from_env
    return cls(
../../../Library/Python/3.9/lib/python/site-packages/docker/client.py:45: in __init__
    self.api = APIClient(*args, **kwargs)
../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:197: in __init__
    self._version = self._retrieve_server_version()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;docker.api.client.APIClient object at 0x107d63e20&gt;

    def _retrieve_server_version(self):
        try:
            return self.version(api_version=False)["ApiVersion"]
        except KeyError:
            raise DockerException(
                'Invalid response from docker daemon: key "ApiVersion"'
                ' is missing.'
            )
        except Exception as e:
&gt;           raise DockerException(
                f'Error while fetching server API version: {e}'
            )
E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker

../../../Library/Python/3.9/lib/python/site-packages/docker/api/client.py:221: DockerException</error></testcase></testsuite></testsuites>